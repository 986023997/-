

# mysql总结

## 1.Mysql的介绍

​				MySQL是一个关系型数据库管理系统，使用sql进行数据库的管理（sql:结构化查询语言，是一种用于数据库管理的语言,主要用于关系型数据库；noSql:not only sql,主要指的是非关系型数据库）,具有开源免费、支持多线程、跨平台、功能强大且使用方便等特点，默认的端口号是3306

## 2.Mysql的常用sql语句和函数

### 2.1sql语言的分类

sql语言分为四类，分别是：数据查询语言DQL，数据管理语言DML,数据控制语言DCL，数据定义语言DDL

DQL：主要查询语句； DML:主要包括插入，更新，删除；DCL：主要用于数据库的授权和事务的申明；DDL:包括建库、索引、试图等

2.2常见的sql语言

建库和使用

create database  test1;

use test1;

查看表

show tables;

#### 建表

create table user(

id bigint (20) not null primary key auto_increment,

name varchar(20) null,

password varchar(20) null

)

查看表机构

 desc user

----------+-------------+------+-----+---------+----------------+-------------------------+
| Field          |     Type        | Null | Key | Default | Extra                    |
+----------+-------------+------+-----+---------+----------------+-----------------------+
| id               | bigint(20)    | NO   | PRI | NULL    | auto_increment |
| name        | varchar(20) | YES  |        | NULL    |                              |
| password | varchar(20) | YES  |        | NULL    |                              |
+----------+-------------+------+-----+---------+--------------+-------------------------+

#### 修改表

alter table user add mobile varchar(20) null;

#### **查询**

select 字段 from 表

select * from user;

#### **插入**

insert into user(name,password) values("xxx","password");

#### **更新**

update user set name="name1"  where name="xxx";

#### **删除**

delete from user where name="name1";

truncate:delete 会写入重做日志，可以恢复，truncate 不会

#### **排序**

Asc(升序，默认为升序)

Desc：降序

#### **分组**

order by （分组的字段名）having  分组条件

#### **分页**

limit

#### **条件查询**

where 

#### **子查询**

#### 联合查询

select 字段 from 表 union select 字段 from 表

连接查询若查询1的记录为n,查询2的记录的m,则总记录为m+n,需要两个查询的字段是一样的，且查询出来的结果会自动过滤

**函数**

**存储过程**

用sql编写的函数

**视图**

create view 视图名;

#### **触发器**

#### **游标**

#### **函数**

#### **事务**

开启事务

begin tranction ;

具体的sql

commit;(提交)

rollback(回滚);

#### **表锁和行锁**

表锁

lock 表名 for write(read)

行锁

select * from user for update

#### 

## 3.mysql的事务

事务:事务是满足acid特性的一组操作

事务的acid特性：

**原子性**（atomicity）

是指原子性，即操作要么全部成功要么全部失败

**一致性（Consistency）**

是指事务的执行前后数据从一个一致性状态到另一个一致性状态

**隔离性（Isolation）**

不同事务之间是不可见的，相互隔离

**持久性（Durability）**

事务一旦提交，结果永久保存到数据库中

**autocommit**

mysql默认开启了自动提交，每一个操作都会当作一个事务自动提交

#### **事务的并发带来的一致性问题**

1.丢失更改：事务a和事务b对同一数据进行修改，事务a提交后事务b提交导致事务a提交的更新丢失

2.脏读：一个事务a读到了另一个事务b还未提交的数据，若此时事务b出现异常导致回滚，事务a依旧会以读到的数据进行更改，导致数据的不一致

3.不可重复读：一个事务多次读取同一个数据，在多次读取的过程中，其他事务对数据进行了更改并提交，导致事务两次读取到的数据不一致

4.幻读：一个事务读取某个一个范围的数据，其他事务进行了插入操作，导致事务的两次读取数据的条数不一致，出现幻读；

#### 事务的隔离级别

ru:读未提交，一个事务可以读取到另一个事务未提及的数据，脏读、不可重复读、幻读都存在

rc：读已提交，一个事务只能读到另一个事务已提交的数据，可以防止脏读

rr：可重复读，对一个数据可以重复读，不能防止幻读

串行化：将多个事务串行化执行

mysql默认的隔离级别是可重复读

## 4.Mysql的表连接

![img](https://img2018.cnblogs.com/blog/1593891/201909/1593891-20190906113427354-810300900.jpg)

自连接：表与自身表的连接，也属于内连接

内连接:inner join,等值连接

左连接：左表的数据以及右表的等值部分的数据

右连接：右边的全部数据，左表的部分数据

左外连接：包含于左表当不包含于右表的数据

右外连接：包含于右表但不包含于左表的数据

全连接：两张表的并集

全外连接：两张表的交集的补集

## 5.Mysql的索引

索引的定义：

一种用于排序的数据结构，类似于建立目录

类型：

hash索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

b树索引：b树多路平衡查找树

**MyISAM**

B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

#### **InnoDB**

其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》

全文索引：

种类：

普通索引：

主键索引：

唯一索引：

组合索引：

全文索引：



**索引的原则：**

1.为常作为查询条件的字段建立索引，同值少区分度高的列

2.不要对索引列做函数操作

3.最左前缀匹配原则

4.尽量的扩展索引，不要新建索引

5.建立索引的列要not null 否则会导致引擎放弃索引进行全表扫描

6.模糊查询以%开头将使用不到索引，

## 6.Mysql的架构和常用引擎之间的区别



## 7.Mysql的日志介绍

7种日志

**重做日志(redo log)**:用来记录事务的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启[mysql](https://www.2cto.com/database/MySQL/)服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。事务的执行过程中，就开始写入，当内存的中的脏页写入到磁盘之后，redo log所占的空间就可以被重用

**二进制日志**：用于主从复制中，在主库中的操作写入bin log,利用io线程将bin log 读取到从库的中继日志，从库中的sql线程将读取中继日志，解析中主服务器的的操作，并在从服务器中replay

**慢查询日志**:记录执行时间过长的日志

**回滚日志**（undo log）：保证数据的原子性，保存事务开始之前的数据的一个版本

**中继日志**(relay log):

**错误日志**:错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。
　　指定日志路径两种方法:

​				编辑my.cnf 写入 log-error=[path]
　　　　通过命令参数错误日志 mysqld_safe –user=mysql –log-error=[path] &

**一般查询日志**：记录数据接受到的查询或命令的日志，不过sql是否正确都会将其记录

## 8.mysql中的锁实现

共享锁（s锁） 读锁

排他锁（x锁）写锁

意向锁

粒度：

表锁

行锁

## 9.Mysql的sql优化

建立索引

explain查看执行过程

优化sql

开启慢查询

show profiles 查看详细的执行流程

## 10.Mysql的主从复制

## 11.分库分表

## 12.高性能sql

## 13.数据库设计三范式

数据库的设计遵循三范式的设计：

1NF:数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项（字段不可分割）

2NF：在1NF的基础上，非码属性必须完全依赖于候选码（要有主键，且非主键字段要依赖于主键）

3NF：在2NF基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（非主键字段，要全部依赖于主键，不能是部分依赖）

//todo 详细介绍

## 14.explain的字段分析

id:

select_type:

table:

partitions:

type:

possible_keys:

key:

key_len:

ref:

rows:

 filtered:

extra:



## 15.mvcc(多版本并发控制）

mvcc多版本并发控制，主要用于解决读写冲突的无锁并发控制，主要用于解决读写冲突的的效率，以及解决脏读，不可重复读，幻读，但是不能解决更新丢失的问题，可以使用mvcc+排他锁 ，解决带有写写冲突的事务并发，

mvcc的实现：依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现

mysql中innodb的当前读和快照读：

**当前读**

读取当前记录最新的数据，读取时需要加锁保证其他事务不会修改当前记录

**快照读**

读取的是某一个记录的快照，可能是最新数据也可能是之前的版本，快照读的实现就是基于mvcc,快照读避免了加锁的操作，减少了冲突，提高了效率

mvcc多版本并发控制指的是维持一个记录的多个版本，使得读写没有冲突



**三个隐式字段：**

DB_TRX_ID：最后一次修改记录的事务id

DB_ROLL_PTR：回滚指针，指向数据的上一个版本

DB_ROW_ID：隐式主键，如果数据库没有主键，innodb会自动以DB_ROW_ID生成一个聚簇索引

**undo日志**

undo log主要分为两种：

- insert undo log
   代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- update undo log
   事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除



undo 其实就是数据的旧纪录链，它的执行流程如下：

1.插入了一条数据name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL，

![img](https://upload-images.jianshu.io/upload_images/3133209-e52ee5ae248c5a08.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

2.现在来了一个事务，将这条数据修改为tom，首先对这行数据加上排他锁，然后该行数据复制到undo日志中，复制完毕之后对该行数据进行修改，修改name为的值为tom之后，并修改DB_TRX_IDdi'c为当前事务的id,默认是从一开始，为当前事务的id,默认是从一开始递增，回滚指针指向undolog中的副本记录，提交事务之后，释放锁。

3.这时候又来了 一个事务，对他进行修改，重复同样的动作，先加锁，然后拷贝副本，修改值，提交事务。

**read view****(读视图)

read view 指的是事务在进行快照读操作的时候产生的一个当前数据库系统的一个快照，里面包含了系统当前活跃的事务id列表，

Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。它遵循一个可见性算法，他的算法过程如下：

1.首先判断当前数据的DB_TRX_ID是否小于当前活跃事务id列表中的最小值，若小于说明是在之前提交了，则当前事务能够看到DB_TRX_ID所在的记录，若大于进入下一步的判断

2.判断DB_TRX_ID是否大于未分配id的下一个值（如当前已分配事务id的最大值为4，则未分配的为5），若大于说明当前事务实在read view生成之后才出现的，所有对当前事务是不可见的，若小于则进入下一步的判断

3.判断DB_TRX_ID是否在活跃事务的id列表中，若在说明事务还在活跃中，还没commit,因此我当前事务是无法看到的，如果不在说明DB_TRX_ID是已经提交过的，因此我当前事务是可以看见的；



**mvcc的整体流程**

当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list



![img](https://upload-images.jianshu.io/upload_images/3133209-cbf70159f8628101.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图



![img](https://upload-images.jianshu.io/upload_images/3133209-1d56c923cf5c6cad.png?imageMogr2/auto-orient/strip|imageView2/2/w/696/format/webp)

我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。



![img](https://upload-images.jianshu.io/upload_images/3133209-615fefab74cacee0.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本



## 16.sql的执行流程

一条sql的执行流程可以大致分为如下几步：

1.首先sql客户端于服务器连接，连接器会验证权限

2.查询缓存，若缓存中有该条sql的结构则直接返回，在mysql8之后没有缓存这个机制了

3.分析器：分析你的sql语句，包括词法分析，语法分析等，判断你的sql是否正确

4.优化器：经过分析sql之后，mysql就可以进行优化得到执行计划，判断是否存在索引，以及是否使用索引，并不是有索引就会走索引，有的时候优化器优化之后会认为走全表效率更高就会放弃索引直接走全表扫描，这个分析是基于一个估算得出的所有有时候并不一定正确，这个时候我们可以考虑让mysql强制走索引

5.执行器：判断你时候有权限执行当前语句

6.执行引擎：通过执行引擎取执行具体的操作





