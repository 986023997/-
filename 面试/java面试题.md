# java基础面试题

#### 1.jdk和jre有什么区别

jdk:java develop kit 是java开发工具包，包含了jre和其他的工具，如编译工具，监控工具等。

jre:是指java运行环境

#### 2.==和equals的区别是什么？

==基本类型比较值，包装类型比较地址，

equals，jdk中的类一般重写了equals,比较的是值，在自定义的类中，若没有重写equals,则调用 Object的equals（）比较，使用的是==

#### 3.基本类型和包装类对象使用==和equals进行比较的结果

如int和integer为例

若值相等，则两者的比较都为true,若值不相等，则两者的比较都为false;

#### 4.什么是装箱、拆箱

装箱：就是将基本类型转化为对应的包装类型，一般使用xxx.valueOf();

拆箱：将包装类型转化为对应的基本类型，一般使用xxx.parse()

#### 5.hashCode相同，equals也一定为true吗？

不一定，equals为true,hashcode也不一定为true

hashCode相同，可能是存在hash冲突了，两个不同的对象得到了相同的hashcode值，则equals的比较一定为false;

也可能是因为错误得重写了Object中的equals和hashcode导致两个对象一个比较相同，一个比较不相同；

#### 6.final在java中的作用

final分别可以修饰类、方法、变量,修饰类表示类不可基础，修饰方法表示方法不能重写（可以重载），修饰变量，若为基本类型，表示值不可变，修改对象引用表示引用不可变

#### 7.final 、finally、finalize()区别

final做修饰，作用如上

finally用于搭配try{}使用，表示在最后运行

finalize()用于对象在垃圾回收之前做处理，不建议使用，因为重写了这个方法之后，在垃圾回收时可能会导致自我救赎

#### 8.finally语句块一定执行吗

不一定，可能程序没有执行到try块中就直接返回了，或抛异常了结束了，

#### 9.finally和static的区别

static和finally都可以修饰方法和变量，但是static只能修饰成员变量，不能修饰局部变量，被static修饰的方法和变量可以通过对象名.方法名/变量名直接访问，static修饰的变量可以重写赋值，static修饰的代码块在类加载的时候就会执行该代码块，且只执行一次，static方法中不能使用this,super等

#### 10.return 与finally的执行顺序对返回值的影响

当return存在于try或finally语句块中时：

finally一定会执行

finally对于return 变量的修改无效

try和finally块中都有return时，以finally为准；

#### 11.String中的replace和replaceAll，replaceFirst

replace替换的是某一个字符，replaceAll通过正则表达式来替换，replaceFirst也是通过正则，但只替换第一个

#### 12.Math.round(-1.5)等于多少

​		-1

#### 13.String属于基础的数据类型吗：

不属于，基础的数据类型有：byte、short、int、char、long、float、double、boolean

#### 14.java中操作字符串的都有哪些类？区别是什么？

String、StringBuild、StringBuffer

String底层使用的是final的字符数组，当对字符串操作时，如拼接，截取时采用的新建一个对象，存储结果到新对象，返回新对象；

StringBuild和StringBuffer

与`String`不同的是，它并不是`final`的，所以他是可以修改的。另外，与`String`不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数

StringBuild是线程不安全的，StringBuffer是用Synconrized修饰的。

#### 15.如何将字符串反转

可以用StringBuild/StringBuffer的reverse（）方法，或自己实现

#### 16.String的常用方法有哪些?

replace()、replaceAll()、replaceFirst()、substring()、charAt()、equals()、concat()、isEmpty()、contains()、length()等；

#### 17.普通类和抽象类的区别?

抽象类用abstact修饰，抽象类不能有实例对象，抽象类的子类必须实现父类的所有抽象方法，否则也是抽象类。抽象方法不能用private修饰，抽象类不能用final修饰，抽象方法只需申明，不需实现

#### 18.抽象类必须有抽象方法？

不需要

#### 19.抽象类能用final修饰吗?

不能，抽象类就是为了给其他类继承和实现；final修饰类表示类不可继承，所有不能。

#### 20.接口和抽象类的区别？

接口用interface声明，接口中只能有抽象方法，抽象类中可以有非抽象方法，

抽象类可以有构造函数，接口不行，

抽象类中的抽象方法可以用除了private的其他的三个访问权限修饰符修饰，而接口中只能是public 修饰，抽象类中可以包含静态方法

抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

一个类可以实现多个接口，但只能继承一个抽象类

#### 21.java中的访问修饰符有哪些？权限的区别

public

可以被其他的任意类访问

 protect 

只能被同一个包中和子类访问

friendly 

只能被同一个包中的类访问

private

只能在当前类中访问

#### 22.java中<<  、 >>、>>>是什么？

<<左移，低位补零

,>>右移,正数高位补零，负数补1

，>>>无符号右移

#### 23.javap的作用

可以用来查看编译生成的字节码文件

#### 24.throw和throws的区别

throw可以用来生成一个异常并抛出

throws用在方法上声明方法可能抛出的异常，方法的调用者需要对异常进行异常处理，如捕获或者继续向上抛出

#### 25.try-catch-finally中那一部分可以省略

catch和finally可以省略其中一个

#### 26.常见的异常类

Throwable类是java中异常的顶级类，它有两个重要子类Error和Exception

Error表⽰系统级的错误， 是java运⾏环境内部错误或者硬件问题， 不能指望程序来处理这样的问题， 除了退出运⾏外别⽆选择， 它是Java虚拟机抛出的。

Exception 表⽰程序需要捕捉、 需要处理的常， 是由与程序设计的不完善⽽出现的问题， 程序必须处理的问题。

Exception又分为一般异常（受检异常）和运行时异常（非受检异常）

#### [受检异常](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/exception-type?id=受检异常)

对于受检异常来说， 如果⼀个⽅法在声明的过程中证明了其要有受检异常抛出：

#### [非受检异常](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/exception-type?id=非受检异常)

对于⾮受检异常来说， ⼀般是运⾏时异常， 继承⾃RuntimeException。 在编写代码的时候， 不需要显⽰的捕获，但是如果不捕获， 在运⾏期如果发⽣异常就会中断程序的执⾏。

这种异常⼀般可以理解为是代码原因导致的。 ⽐如发⽣空指针、 数组越界等。 所以， 只要代码写的没问题， 这些异常都是可以避免的。 也就不需要我们显⽰的进⾏处理。

#### 27.什么是java内部类

存在于java类的内部java类

分类：

成员内部类：成员内部类是最普通的内部类，它的定义为位于另一个类的内部

静态内部类：与成员内部类类似，用static修饰，不依赖于外部类

局部内部类：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内

匿名内部类：匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名

#### 28.nio中的File类常用方法有哪些？ 

#### 29.什么的反射？反射的作用？

反射是指在程序运行时获取任意类的属性，方法等信息，。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。

作用：

在运行时判断任意一个对象所属的类。

在运行时判断任意一个类所具有的成员变量和方法。

在运行时任意调用一个对象的方法

在运行时构造任意一个类的对象

java的动态就体现在反射，通过反射实现动态装配，降低代码的耦合性，动态代理等

#### 30.动态代理是什么？应用场景

动态代理：在运行是，创建一个目标类，并为代理类提供增强，对目标类进行动态扩展

静态代理：由开发者自己编写，代理模式中的所有角色（代理对象、目标对象、目标对象的接口）等都是在编译期就确定好的

动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能。

#### 31.怎么实现动态代理

1.jdk的动态代理：java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。

2.CGlib的动态代理：Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。

JDK动态代理和Cglib动态代理的区别 JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。

#### 32.什么是java序列化，什么情况下需要序列化？

java序列化，就是将对象转化为字节流的过程，是一种数据的持久化手段，一般广泛应用于网络传输，RMI和RPC等场景中。

反序列化是序列化的逆操作，将字节流转化为java对象的过程

序列化需要类实现了serializable接口，static和transient声明的成员变量不会进行序列化。

除了serializable接口可以序列化还有Externalizable接口也可以提供序列化，

Externalizable继承了Serializable，该接口中定义了两个抽象方法：`writeExternal()`与`readExternal()`。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写`writeExternal()`与`readExternal()`方法。若没有定义序列化实现细节，输出的内容为空。还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。

#### 33.什么场景要对对象克隆？

方法传参的时候，传递的引用类型的参数不希望被改变的时候。

#### 34.深拷贝和浅拷贝的区别

拷贝的对象中若只有基本类型，则没有区别，若有引用类型，在浅拷贝时，引用类型的属性复制，共用同一对象，深拷贝是属性复制，且引用的对象也会复制一份，这样 引用对象不共用

#### 35.如何实现对象的克隆和深拷贝

对象实现Cloneable接口，重写clone方法，深拷贝中若有引用类型，则引用类型对于的类也要实现该接口，并重写方法

#### 36.java跨平台的原理

java跨平台是通过jvm来实现的，java源文件通过前端编译器得到字节码文件，如何将字节码通过java虚拟机编译为机器码运行，虽然java与平台无关，但是jvm与平台相关，不同的操作系统，jvm的实现会有一些不同，但是提供给jdk的接口是一样的。

#### 37.java的安全性体现在哪?

有垃圾回收机制，不需要程序运自己去管理内存，依赖gc机制实现内存的回收，

强类型语言，

拥有完整的异常处理机制

字节码传输使用了加密机制

#### 38.java针对不同的应用场景提供了哪些版本？

j2se、j2ee、j2me

#### 39.什么是jvm

jvm即java虚拟机用于 对源文件编译的字节码进行编译为机器码，有自己的指令集，基于栈的指令集，

#### 40.jdk的目录

bin:各种命令工具，java源码的编译器、javac、jconsole等

include:与jvm交互c语言用的头文件

lib:类库

jre:java运行环境

#### 41.java中的注释方式

1.单行注释

2.多行注释

3.文档注释

#### 42.基本数据类型

byte 1字节

short 2字节

int 4字节

char2字节

long 8字节

float 4字节

double 8字节

#### 43.i++和++i的区别

i++先运算，在加1

++i先加1再运算

#### 46.&和&&的作用和区别

&逻辑与，进行与运算

&&断路于，当左边表达式的结果位false时，不会进行右边表达式的运算。

#### 47.如何高效算出2乘以8

2<<3

进行左移3位

#### 48.java中基本类型的转换规则

等级从低到高：

byte 、short、int、long、float、double、

char、int 、long、float、double

自动转换，低级可以自动向高级转换

强制转换：高级强制转换为低级，可能会出现丢失精度

#### 49.可变参数

作用:在不确定参数个数时，可以使用可变参数。

#### 50.面向对象和面向过程

面向过程：自顶向下，逐步细化，将问题分解为一个一个步骤，每个步骤用函数实现，占用资源少，速度相对快

面向过程：将问题分解为一个一个步骤，每个步骤抽象为对象，通过对象的组合操作，解决问题

，占用资源多，速度慢

#### 51.面向对象的三大基本特征

封装

就是将一类客观事物封装成抽象的类，并且类可以把自己的数据的方法让可信的类或对象操作，对不可信的进行信息屏蔽

继承

使用现有类的功能，在无需重写编写原来的类的情况下对类进行功能扩展，通过继承创建的类称为“子类”或“派生类”，被继承的叫做”父类“，“基类”、“超类”

多态

多态指一个类实例的相同方法在不同情形下有不同表现形式。

#### 52.面向对象的5大基本原则

开闭原则：对扩展开发，对修改关闭

单一职责：一个类最好只做一件事

接口隔离：使用多个小的专门的接口，而不要使用一个大的总接口。

里氏替换原则：子类必须能够替换其基类

依赖倒置原则：具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 

#### 53.什么是多态

是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

#### 54.方法的重载和重写

方法的重载是在同一个类中，同名方法有不同的参数列表，如参数个数不同，参数的类型不同等，这样的方法叫重载

重写是在不同类中，子类对于父类方法的重写，方法的参数列表等要一致，方法体可以不一致。

#### 55.jvm还支持哪些语言

Kotlin、Groovy、JRuby、Jython、Scala

#### 56.值传递和引用传递

在有参函数的调用过程中，涉及到参数的传递，分两种：

值传递：将实际参数的值复制一份传到方法中，在方法的执行过程中对参数的修改不会影响到实际参数

引用传递：将实际参数的地址传递到方法中，对参数的修改，会影响到实际参数

#### 57.为什么说java中只有值传递？

在java中对基本类型复制一份参数传递到方法中，对于引用类型，也是复制一份引用类型的值传递到方法中，但是因为引用类型中存的是对象的地址，所以对于传递的引用类型在方法中的修改也会影响到实际参数，所有在java中只有值传递。

#### 58.为什么不能用浮点型表示金额？

浮点型在计算机中保存的是近似值，所有不能使用浮点数来表示金额等重要指标

#### 59.Integer的缓存机制

这是java5中为了提高程序性能，节约内存的功能，

适用于整数值区间-128 至 +127。

只适用于自动装箱。使用构造函数创建对象不适用。

#### 60。String对“+”的重载

1. String s = "a" + "b"，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = "ab"
2. 对于能够进行优化的(String s = "a" + 变量 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())

#### 61.字符串常量池

当代码中出现双引号的字符串定义赋值，这种形式叫做“字面量”（字面量（literal）是用于表达源代码中一个固定值的表示法（notation）），当代码中出现这种形式创建字符串对象时，jvm会先检查如果字符串常量池中存在相同内容的字符串对象的引用，否则创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用

#### 62.Class常量池

Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

![-w697](http://www.hollischuang.com/wp-content/uploads/2018/10/15401192359009.jpg)

#### 63.instanceof 

instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。

## 

#### 64.static关键字的作用

static可以修饰变量、方法、代码块、内部类

static变量是这个类所有，即该类创建的所有实例共享一个static属性

static变量在内存中只有一份

static方法可以直接通过类名.方法名和对象名.方法名

static代码块在类第一次加载的时候就执行，且只被执行一次

#### 65.子类构造方法的执行过程是怎样的

调用规则：

1.若子类的构造方法中没有显示调用父类的有参构造函数，也没有显示调用自身的其他构造方法，则会默认先调用父类的无参构造函数

2.如果子类的构造方法调用了父类的有参构造函数，则不调用父类的无参构造

3.如果子类的构造方法中显示的调用了其他的构造方法，则执行类中的相应的构造方法

4.存在多级继承关系，在创建子类对象时，会一直执行到最高级父类Object的无参构造方法

#### 66.什么是java的垃圾回收机制？

垃圾回收机制，简称gc

优点：

不需要程序员直接控制内存的回收

提高编程效率

保护程序的完整性

#### 67.内存泄漏和内存溢出的区别

内存泄漏：是指一个对象的应用被回收，但是对象却没有回收，且没有其他地方用到，造成内存泄漏

内存溢出：是指内存被不断使用，当直接内存没有空间再为jvm分配内存的时候就会报内存溢出

#### 68.java是属于编译型还是解释型语言

java属于半解释型半编译型的语言，解释和编译共存

#### 69.反射的主要实现类有哪些

每个类都有一个 **Class** 对象，包含了与类有关的信息

Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：

- **Field** ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 的 newInstance() 创建新的对象。

#### 70.Class类的作用是什么？如何获取Class对象

 **Class** 对象，包含了与类有关的信息，

获取：

对象.getClass;

```
Class.forName("类")
```

类.class;

#### 71.反射的使用场景、作用和优缺点

反射主要是在框架底层中使用，

作用：

通过反射在运行时获得类的信息，在运行时加载类

优点：

可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。

```
*类浏览器和可视化开发环境**   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
```

```
**调试器和测试工具**   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。
```

缺点：

```
**性能开销**   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
```

```
**安全限制**   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
```

```
**内部暴露**   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
```

#### 72.为什么String类被设计用final修饰

1.因为String使用频繁，使用final禁止被继承和重写

2.安全性

#### 72.说说反射在实际开发中的应用

反射使用不好，对性能影响比较，一般项目中很少直接使用。

反射主要用于底层的框架中，Spring 中就大量使用了反射，比如：

- 用 IoC 来注入和组装 bean
- 动态代理、面向切面、bean 对象中的方法替换与增强，也使用了反射
- 定义的注解，也是通过反射查找

#### 73.什么是泛型？为什么要使用泛型？

Java泛型（ generics） 是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数（ type parameter） 。

泛型最⼤的好处是可以提⾼代码的复⽤性。 以List接⼜为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。

#### 74.什么是枚举

枚举类型（`enum type`）是指由一组固定的常量组成合法的类型。`Java`中由关键字`enum`来定义一个枚举类型。下面就是`java`枚举类型的定义。

使用枚举设计单例是一种非常好的方式

#### 75.字符流、字节流

##### [字节流](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/byte-stream-vs-character-stream?id=字节流)

操作byte类型数据，主要操作类是OutputStream、InputStream的子类；不用缓冲区，直接对文件本身操作。

##### [字符流](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/byte-stream-vs-character-stream?id=字符流)

操作字符类型数据，主要操作类是Reader、Writer的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。

#### 76.同步、异步、阻塞、非阻塞

同步与异步描述的是被调用者的。

如A调用B：

如果是同步，B在接到A的调用后，会立即执行要做的事。A的本次调用可以得到结果。

如果是异步，B在接到A的调用后，不保证会立即执行要做的事，但是保证会去做，B在做好了之后会通知A。A的本次调用得不到结果，但是B执行完之后会通知A。

[阻塞、非阻塞](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/block-vs-non-blocking)，是描述调用方的。

举个简单的例子，老张烧水。 1 老张把水壶放到火上，一直在水壶旁等着水开。（同步阻塞） 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 3 老张把响水壶放到火上，一直在水壶旁等着水开。（异步阻塞） 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）

#### 77.Linux 5种IO模型

##### 阻塞式io

最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。

当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

##### 非阻塞io

当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

##### io复用

多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。

在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

##### 信号驱动io

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

异步io

前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。

#### 78.BIO、NIO和AIO的区别、三种IO的用法与原理

##### BIO

阻塞io ， 同步并阻塞的IO

##### NIO

什么是NIO? NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。

面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。

一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

##### AIO

Java AIO即Async非阻塞，是异步非阻塞的IO。

##### 各自适用场景

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持

#### 79.注解

##### 元注解

定义其他注解的注解 。 比如Override这个注解，就不是一个元注解。而是通过元注解定义出来的。

元注解有四个:@Target（表示该注解可以用于什么地方）、@Retention（表示再什么级别保存该注解信息）、@Documented（将此注解包含再javadoc中）、@Inherited（允许子类继承父类中的注解）。

##### 自定义注解

除了元注解，都是自定义注解。通过元注解定义出来的注解。 如我们常用的Override 、Autowire等。 日常开发中也可以自定义一个注解，这些都是自定义注解。